"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var TestCase_1 = __importDefault(require("./TestCase"));
var EmptyPickleTestStep_1 = __importDefault(require("./EmptyPickleTestStep"));
function makeTestCase(pickle, stepDefinitions, beforeHooks, afterHooks, gherkinQuery, newId, clock, makeErrorMessage, makePickleTestStep, makeHookStep) {
    if (pickle.steps.length === 0) {
        var id = newId();
        var undefinedStep = new EmptyPickleTestStep_1.default(id, undefined, true, [], [], clock, makeErrorMessage);
        return new TestCase_1.default(newId(), [undefinedStep], pickle.id, clock);
    }
    var beforeHookSteps = makeHookSteps(pickle, beforeHooks, false, gherkinQuery, newId, clock, makeErrorMessage, makeHookStep);
    var pickleTestSteps = pickle.steps.map(function (pickleStep) {
        var sourceFrames = pickleStep.astNodeIds.map(function (astNodeId) { return pickle.uri + ":" + gherkinQuery.getLocation(astNodeId).line; });
        return makePickleTestStep(newId(), pickleStep, stepDefinitions, sourceFrames, clock, makeErrorMessage);
    });
    var afterHookSteps = makeHookSteps(pickle, afterHooks, true, gherkinQuery, newId, clock, makeErrorMessage, makeHookStep);
    var testSteps = []
        .concat(beforeHookSteps)
        .concat(pickleTestSteps)
        .concat(afterHookSteps);
    return new TestCase_1.default(newId(), testSteps, pickle.id, clock);
}
exports.default = makeTestCase;
function makeHookSteps(pickle, hooks, alwaysExecute, gherkinQuery, newId, clock, makeErrorMessage, makeHookStep) {
    return hooks
        .map(function (hook) {
        return makeHookStep(pickle, hook, alwaysExecute, gherkinQuery, newId, clock, makeErrorMessage);
    })
        .filter(function (testStep) { return testStep !== undefined; });
}
//# sourceMappingURL=makeTestCase.js.map