"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cucumber_expressions_1 = require("@cucumber/cucumber-expressions");
var messages_1 = require("@cucumber/messages");
var ExpressionStepDefinition_1 = __importDefault(require("./ExpressionStepDefinition"));
var Hook_1 = __importDefault(require("./Hook"));
var ErrorMessageGenerator_1 = require("./ErrorMessageGenerator");
var PerfHooksClock_1 = __importDefault(require("./PerfHooksClock"));
function defaultTransformer() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args;
}
/**
 * This class provides an API for defining step definitions and hooks.
 */
var SupportCode = /** @class */ (function () {
    function SupportCode(newId, clock, makeErrorMessage) {
        if (newId === void 0) { newId = messages_1.IdGenerator.uuid(); }
        if (clock === void 0) { clock = new PerfHooksClock_1.default(); }
        if (makeErrorMessage === void 0) { makeErrorMessage = ErrorMessageGenerator_1.withFullStackTrace(); }
        this.newId = newId;
        this.clock = clock;
        this.makeErrorMessage = makeErrorMessage;
        this.parameterTypes = [];
        this.parameterTypeMessages = [];
        this.stepDefinitions = [];
        this.beforeHooks = [];
        this.afterHooks = [];
        this.parameterTypeRegistry = new cucumber_expressions_1.ParameterTypeRegistry();
        this.expressionFactory = new cucumber_expressions_1.ExpressionFactory(this.parameterTypeRegistry);
        this.undefinedParameterTypeMessages = [];
    }
    SupportCode.prototype.defineParameterType = function (parameterTypeDefinition) {
        var parameterType = new cucumber_expressions_1.ParameterType(parameterTypeDefinition.name, parameterTypeDefinition.regexp, parameterTypeDefinition.type, parameterTypeDefinition.transformer || defaultTransformer, parameterTypeDefinition.useForSnippets, parameterTypeDefinition.preferForRegexpMatch);
        this.parameterTypeRegistry.defineParameterType(parameterType);
        this.parameterTypes.push(parameterType);
        this.parameterTypeMessages.push(new messages_1.messages.Envelope({
            parameterType: new messages_1.messages.ParameterType({
                id: this.newId(),
                name: parameterType.name,
                regularExpressions: parameterType.regexpStrings.slice(),
                preferForRegularExpressionMatch: parameterType.preferForRegexpMatch,
                useForSnippets: parameterType.useForSnippets,
            }),
        }));
    };
    SupportCode.prototype.defineStepDefinition = function (sourceReference, expression, body) {
        try {
            var expr = this.expressionFactory.createExpression(expression);
            var stepDefinition = new ExpressionStepDefinition_1.default(this.newId(), expr, sourceReference, body);
            this.registerStepDefinition(stepDefinition);
        }
        catch (e) {
            if (e.undefinedParameterTypeName) {
                this.undefinedParameterTypeMessages.push(new messages_1.messages.Envelope({
                    undefinedParameterType: new messages_1.messages.UndefinedParameterType({
                        expression: expression.toString(),
                        name: e.undefinedParameterTypeName,
                    }),
                }));
            }
            else {
                throw e;
            }
        }
    };
    SupportCode.prototype.registerStepDefinition = function (stepDefinition) {
        this.stepDefinitions.push(stepDefinition);
    };
    SupportCode.prototype.defineBeforeHook = function (sourceReference, tagExpressionOrBody, body) {
        this.registerBeforeHook(this.makeHook(sourceReference, tagExpressionOrBody, body));
    };
    SupportCode.prototype.registerBeforeHook = function (hook) {
        this.beforeHooks.push(hook);
    };
    SupportCode.prototype.defineAfterHook = function (sourceReference, tagExpressionOrBody, body) {
        this.registerAfterHook(this.makeHook(sourceReference, tagExpressionOrBody, body));
    };
    SupportCode.prototype.registerAfterHook = function (hook) {
        this.afterHooks.push(hook);
    };
    SupportCode.prototype.makeHook = function (sourceReference, tagExpressionOrBody, body) {
        var tagExpression = typeof tagExpressionOrBody === 'string' ? tagExpressionOrBody : null;
        body = typeof tagExpressionOrBody !== 'string' ? tagExpressionOrBody : body;
        return new Hook_1.default(this.newId(), tagExpression, sourceReference, body);
    };
    return SupportCode;
}());
exports.default = SupportCode;
//# sourceMappingURL=SupportCode.js.map