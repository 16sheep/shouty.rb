"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var JSONTraverse_1 = require("../cucumber-ruby/JSONTraverse");
var JSONTraverse_2 = require("../cucumber-generic/JSONTraverse");
function durationToMillis(duration) {
    return duration ? duration / 1000000 : 0;
}
function traverseFeature(feature, astMaker, newId, predictableSupportCode) {
    return JSONTraverse_2.traverseFeature(feature, astMaker, newId, predictableSupportCode, traverseElement);
}
exports.traverseFeature = traverseFeature;
function traverseElement(element, astMaker, newId, predictableSupportCode) {
    var e_1, _a, e_2, _b, e_3, _c;
    var beforeHooks = [];
    var scenarioSteps = [];
    var afterHooks = [];
    var currentStepIs = 'before';
    try {
        for (var _d = __values(element.steps), _e = _d.next(); !_e.done; _e = _d.next()) {
            var step = _e.value;
            if (currentStepIs === 'before' && !step.hidden) {
                currentStepIs = 'scenario';
            }
            else if (currentStepIs === 'scenario' && step.hidden) {
                currentStepIs = 'after';
            }
            switch (currentStepIs) {
                case 'before': {
                    beforeHooks.push(step);
                    break;
                }
                case 'scenario': {
                    scenarioSteps.push(step);
                    break;
                }
                case 'after': {
                    afterHooks.push(step);
                    break;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var tags = element.tags
        ? element.tags.map(function (tag) { return JSONTraverse_2.traverseTag(tag, astMaker); })
        : undefined;
    var featureChild = astMaker.makeScenarioFeatureChild(newId(), element.line, element.keyword, element.name, element.description, scenarioSteps.map(function (step) {
        return traverseStep(step, astMaker, newId, predictableSupportCode);
    }), tags);
    try {
        for (var beforeHooks_1 = __values(beforeHooks), beforeHooks_1_1 = beforeHooks_1.next(); !beforeHooks_1_1.done; beforeHooks_1_1 = beforeHooks_1.next()) {
            var hook = beforeHooks_1_1.value;
            traverseBeforeHook(hook, featureChild.scenario, predictableSupportCode);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (beforeHooks_1_1 && !beforeHooks_1_1.done && (_b = beforeHooks_1.return)) _b.call(beforeHooks_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    try {
        for (var afterHooks_1 = __values(afterHooks), afterHooks_1_1 = afterHooks_1.next(); !afterHooks_1_1.done; afterHooks_1_1 = afterHooks_1.next()) {
            var hook = afterHooks_1_1.value;
            traverseAfterHook(hook, featureChild.scenario, predictableSupportCode);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (afterHooks_1_1 && !afterHooks_1_1.done && (_c = afterHooks_1.return)) _c.call(afterHooks_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return featureChild;
}
exports.traverseElement = traverseElement;
function traverseBeforeHook(step, scenario, predictableSupportCode) {
    predictableSupportCode.addPredictableBeforeHook(step.match.location, scenario.id, step.result.status, durationToMillis(step.result.duration), step.result.error_message);
}
exports.traverseBeforeHook = traverseBeforeHook;
function traverseAfterHook(step, scenario, predictableSupportCode) {
    predictableSupportCode.addPredictableAfterHook(step.match.location, scenario.id, step.result.status, durationToMillis(step.result.duration), step.result.error_message);
}
exports.traverseAfterHook = traverseAfterHook;
function traverseStep(step, astMaker, newId, predictableSupportCode) {
    var stepArguments = step.arguments || [];
    var docStringArgument = stepArguments.find(function (arg) { return arg.content; });
    var docString = docStringArgument
        ? traverseDocString(docStringArgument, astMaker)
        : null;
    var datatableArgument = stepArguments.find(function (arg) { return arg.rows; });
    var datatable = datatableArgument
        ? JSONTraverse_1.traverseDataTable(datatableArgument.rows, astMaker)
        : null;
    var gherkinStep = astMaker.makeStep(newId(), step.line, step.keyword, step.name, docString, datatable);
    if (gherkinStep && step.match) {
        predictableSupportCode.addPredictableStepDefinition(step.match.location, gherkinStep.id, step.result.status, durationToMillis(step.result.duration), step.result.error_message);
    }
    return gherkinStep;
}
exports.traverseStep = traverseStep;
function traverseDocString(docString, astMaker) {
    return astMaker.makeDocstring(null, docString.content);
}
exports.traverseDocString = traverseDocString;
//# sourceMappingURL=JSONTraverse.js.map